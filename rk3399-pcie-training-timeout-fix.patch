diff --git a/drivers/pci/controller/pcie-rockchip-host.c b/drivers/pci/controller/pcie-rockchip-host.c
index 7352b5ff8..ec0d24778 100644
--- a/drivers/pci/controller/pcie-rockchip-host.c
+++ b/drivers/pci/controller/pcie-rockchip-host.c
@@ -298,9 +298,10 @@ static void rockchip_pcie_set_power_limit(struct rockchip_pcie *rockchip)
 static int rockchip_pcie_host_init_port(struct rockchip_pcie *rockchip)
 {
 	struct device *dev = rockchip->dev;
-	int err, i = MAX_LANE_NUM;
+	int err, i = MAX_LANE_NUM, attempt_counter=0;
 	u32 status;
 
+err_retry_init:
 	gpiod_set_value_cansleep(rockchip->ep_gpio, 0);
 
 	err = rockchip_pcie_init_port(rockchip);
@@ -337,7 +337,7 @@ static int rockchip_pcie_host_init_port(struct rockchip_pcie *rockchip)
 				 status, PCIE_LINK_UP(status), 20,
 				 500 * USEC_PER_MSEC);
 	if (err) {
-		dev_err(dev, "PCIe link training gen1 timeout!\n");
+		dev_err(dev, "PCIe link training gen1 timeout with status %d!\n", status);
 		goto err_power_off_phy;
 	}
 
@@ -352,9 +352,9 @@ static int rockchip_pcie_host_init_port(struct rockchip_pcie *rockchip)
 
 		err = readl_poll_timeout(rockchip->apb_base + PCIE_CORE_CTRL,
 					 status, PCIE_LINK_IS_GEN2(status), 20,
					 500 * USEC_PER_MSEC);
 		if (err)
-			dev_dbg(dev, "PCIe link training gen2 timeout, fall back to gen1!\n");
+			dev_dbg(dev, "PCIe link training gen2 timeout with status %d, fall back to gen1!\n",status);
 	}
 
 	/* Check the final link width from negotiated lane counter from MGMT */
@@ -402,6 +402,8 @@ static int rockchip_pcie_host_init_port(struct rockchip_pcie *rockchip)
 	i = MAX_LANE_NUM;
 	while (i--)
 		phy_exit(rockchip->phys[i]);
+	if (attempt_counter++ < 5)
+		goto err_retry_init;
 	return err;
 }
